# PowerShell script to rebuild MQ2LinkDB with complete Lucy item data
# This script:
# 1. Scans all Lucy JSON files to determine all possible fields (cached after first run)
# 2. Creates a new raw_item_data table with all fields as columns
# 3. Populates the table with complete data from Lucy JSON files
# 4. Replaces the old table

param(
    [int]$BatchSize = 2000,
    [string]$DbPath = "C:\MQ2\lua\yalm2\MQ2LinkDB.db",
    [string]$LucyDir = "D:\Lucy",
    [switch]$DryRun,
    [switch]$BackupFirst,
    [switch]$RescanFields
)

# Import SQLite module
Import-Module PSSQLite -ErrorAction Stop

Write-Host "=== MQ2LinkDB Rebuild from Complete Lucy Data ===" -ForegroundColor Green
Write-Host "Database: $DbPath"
Write-Host "Lucy Directory: $LucyDir"
Write-Host "Batch Size: $BatchSize"
if ($DryRun) { Write-Host "DRY RUN MODE - No database changes will be made" -ForegroundColor Yellow }
if ($BackupFirst) { Write-Host "BACKUP MODE - Will create backup before changes" -ForegroundColor Yellow }
if ($RescanFields) { Write-Host "RESCAN MODE - Will re-scan all Lucy files for fields" -ForegroundColor Yellow }
Write-Host ""

# Verify database and Lucy directory exist
if (!(Test-Path $DbPath)) {
    Write-Error "Database not found at: $DbPath"
    exit 1
}

if (!(Test-Path $LucyDir)) {
    Write-Error "Lucy directory not found at: $LucyDir"
    exit 1
}

# Define cache file for field list
$cacheDir = Split-Path $DbPath
$cacheFile = Join-Path $cacheDir "lucy_fields_cache.txt"

# Step 1: Get field list from a sample Lucy file (all files have same structure)
Write-Host "Step 1: Reading field structure from sample Lucy file..." -ForegroundColor Cyan

if ($null -eq $fieldList) {
    # Just read one Lucy file to get the schema - all files have identical structure
    $sampleFile = Get-ChildItem "$LucyDir\lucy_item_*.json" | Select-Object -First 1
    
    Write-Host "  Reading: $($sampleFile.Name)" -ForegroundColor Gray
    
    try {
        $content = Get-Content $sampleFile.FullName -Raw -ErrorAction Stop
        $sampleData = $content | ConvertFrom-Json -AsHashTable -ErrorAction Stop
        $fieldList = $sampleData.Keys | Sort-Object
        
        Write-Host "  Found $($fieldList.Count) fields in Lucy structure"
        Write-Host "  Sample fields: $(($fieldList | Select-Object -First 20) -join ', ')..." -ForegroundColor Gray
        
        # Note: One field will be the item name (varies per item), others are consistent
        Write-Host "  (Note: Item names are stored as individual fields per item)" -ForegroundColor Gray
    }
    catch {
        Write-Error "Failed to read sample Lucy file: $($_.Exception.Message)"
        exit 1
    }
}

Write-Host ""

# Step 2: Create new table with all fields
Write-Host "Step 2: Creating new table schema with all fields..." -ForegroundColor Cyan

if (!$DryRun) {
    # Backup existing table if requested
    if ($BackupFirst) {
        Write-Host "  Creating backup of raw_item_data..." -ForegroundColor Yellow
        $backupName = "raw_item_data_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
        try {
            Invoke-SqliteQuery -DataSource $DbPath -Query "ALTER TABLE raw_item_data RENAME TO $backupName"
            Write-Host "  Backup created as: $backupName" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to create backup: $($_.Exception.Message)"
            exit 1
        }
    }
    else {
        # Drop existing table without backup
        Write-Host "  Dropping existing raw_item_data table..." -ForegroundColor Yellow
        try {
            Invoke-SqliteQuery -DataSource $DbPath -Query "DROP TABLE IF EXISTS raw_item_data"
            Write-Host "  Old table dropped" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to drop table: $($_.Exception.Message)"
            exit 1
        }
    }
    
    # Create new table with all fields
    $columnDefs = @('"id" INTEGER PRIMARY KEY')
    
    foreach ($field in $fieldList) {
        # Skip id since it's already the primary key
        if ($field -eq 'id') { continue }
        
        # Escape field names that might have special characters
        $safeField = $field -replace '[^a-zA-Z0-9_]', '_'
        
        # Most Lucy fields are text/strings based on JSON structure
        $columnDefs += """$safeField"" TEXT"
    }
    
    $createTableSql = "CREATE TABLE raw_item_data ($(($columnDefs) -join ', '))"
    
    try {
        Invoke-SqliteQuery -DataSource $DbPath -Query $createTableSql -ErrorAction Stop
        Write-Host "  New table created with $($fieldList.Count) columns" -ForegroundColor Green
    }
    catch {
        Write-Error "Failed to create table: $($_.Exception.Message)"
        exit 1
    }
}
else {
    Write-Host "  DRY RUN: Would create table with $($fieldList.Count) columns"
}
Write-Host ""

# Step 3: Populate table from Lucy JSON files
Write-Host "Step 3: Populating table from Lucy JSON files..." -ForegroundColor Cyan

$processedCount = 0
$successCount = 0
$errorCount = 0
$skippedCount = 0

# Process files in batches
for ($i = 0; $i -lt $totalFiles; $i += $BatchSize) {
    $batchNumber = [math]::Floor($i / $BatchSize) + 1
    $endIndex = [math]::Min($i + $BatchSize - 1, $totalFiles - 1)
    $batchFiles = $lucyFiles[$i..$endIndex]
    
    $batchFileCount = ($batchFiles | Measure-Object).Count
    Write-Host "  Batch $batchNumber : Processing $batchFileCount files..." -ForegroundColor Cyan
    
    foreach ($file in $batchFiles) {
        try {
            if ($file.Name -match "lucy_item_(\d+)\.json") {
                $itemId = [int]$matches[1]
                
                $content = Get-Content $file.FullName -Raw -ErrorAction Stop
                $data = $content | ConvertFrom-Json -AsHashTable -ErrorAction Stop
                
                if (!$DryRun) {
                    # Build INSERT statement with all available fields
                    $columnsToInsert = @('id')
                    $valuesToInsert = @()
                    $parameterArray = @($itemId)
                    
                    foreach ($field in $fieldList) {
                        if ($field -eq 'id') { continue }
                        
                        $safeField = $field -replace '[^a-zA-Z0-9_]', '_'
                        if ($null -ne $data.$field -and $data.$field -ne '') {
                            $columnsToInsert += """$safeField"""
                            $valuesToInsert += '?'
                            $parameterArray += [string]$data.$field
                        }
                    }
                    
                    $sql = "INSERT INTO raw_item_data ($(($columnsToInsert) -join ', ')) VALUES (?, $(($valuesToInsert) -join ', '))"
                    $null = Invoke-SqliteQuery -DataSource $DbPath -Query $sql -SqlParameters $parameterArray -ErrorAction Stop
                    $successCount++
                }
                else {
                    $successCount++
                }
            }
            else {
                Write-Warning "Could not extract item ID from: $($file.Name)"
                $skippedCount++
            }
        }
        catch {
            Write-Error "Error processing $($file.Name): $($_.Exception.Message)"
            $errorCount++
        }
        
        $processedCount++
        
        if ($processedCount % 5000 -eq 0) {
            $percentComplete = [math]::Round(($processedCount / $totalFiles) * 100, 2)
            Write-Host "    Progress: $processedCount / $totalFiles ($percentComplete%) - Success: $successCount, Errors: $errorCount"
        }
    }
}

Write-Host ""
Write-Host "=== Rebuild Complete ===" -ForegroundColor Green
Write-Host "Total files processed: $processedCount"
Write-Host "Successfully inserted: $successCount"
Write-Host "Errors: $errorCount"
Write-Host "Skipped: $skippedCount"
Write-Host "Total columns in new table: $($fieldList.Count)"

if (!$DryRun) {
    Write-Host ""
    Write-Host "Verifying data..." -ForegroundColor Cyan
    $itemCount = Invoke-SqliteQuery -DataSource $DbPath -Query "SELECT COUNT(*) as count FROM raw_item_data"
    Write-Host "Items in database: $($itemCount[0].count)"
}

# Get all Lucy JSON files
Write-Host "Scanning for Lucy JSON files..." -ForegroundColor Cyan
$lucyFiles = Get-ChildItem "$LucyDir\lucy_item_*.json" | Sort-Object Name
$totalFiles = $lucyFiles.Count
Write-Host "Found $totalFiles Lucy JSON files" -ForegroundColor Green

if ($totalFiles -eq 0) {
    Write-Error "No Lucy JSON files found in $LucyDir"
    exit 1
}

# Verify database exists
if (!(Test-Path $DbPath)) {
    Write-Error "Database not found at: $DbPath"
    exit 1
}

# Initialize counters
$processedCount = 0
$successCount = 0
$errorCount = 0
$skippedCount = 0
$batchCount = 0

# Function to process a batch of files
function Update-Batch {
    param($Files, $BatchNumber)
    
    Write-Host "Processing batch $BatchNumber ($($Files.Count) files)..." -ForegroundColor Cyan
    
    $updates = @()
    
    foreach ($file in $Files) {
        try {
            # Extract item ID from filename
            if ($file.Name -match "lucy_item_(\d+)\.json") {
                $itemId = [int]$matches[1]
                
                # Read and parse JSON
                $content = Get-Content $file.FullName -Raw -ErrorAction Stop
                $data = $content | ConvertFrom-Json -ErrorAction Stop
                
                # Collect all Lucy fields that exist in this item
                $itemData = @{ ItemId = $itemId }
                foreach ($field in $lucyFields) {
                    if ($null -ne $data.$field -and $data.$field -ne "") {
                        $itemData[$field] = $data.$field
                    }
                }
                
                $updates += $itemData
                
            } else {
                Write-Warning "Could not extract item ID from filename: $($file.Name)"
                $script:skippedCount++
            }
        }
        catch {
            Write-Error "Error processing $($file.Name): $($_.Exception.Message)"
            $script:errorCount++
        }
        
        $script:processedCount++
        
        # Progress update
        if ($script:processedCount % 1000 -eq 0) {
            $percentComplete = [math]::Round(($script:processedCount / $totalFiles) * 100, 2)
            Write-Progress -Activity "Processing Lucy Files" -Status "$script:processedCount of $totalFiles processed ($percentComplete%)" -PercentComplete $percentComplete
        }
    }
    
    # Execute batch database update
    if ($updates.Count -gt 0 -and !$DryRun) {
        try {
            Write-Host "Updating database with $($updates.Count) items..." -ForegroundColor Yellow
            
            foreach ($update in $updates) {
                # Build dynamic SQL with all available fields
                $setFields = @()
                $sqlParams = @{}
                
                foreach ($field in $lucyFields) {
                    if ($null -ne $update.$field) {
                        $setFields += "$field = @$field"
                        $sqlParams[$field] = $update.$field
                    }
                }
                
                if ($setFields.Count -gt 0) {
                    $sql = "UPDATE raw_item_data SET $($setFields -join ', ') WHERE id = @id"
                    $sqlParams['id'] = $update.ItemId
                    
                    $null = Invoke-SqliteQuery -DataSource $DbPath -Query $sql -SqlParameters $sqlParams -ErrorAction Stop
                    $script:successCount++
                }
            }
            
            Write-Host "Batch $BatchNumber completed successfully" -ForegroundColor Green
        }
        catch {
            Write-Error "Database update error in batch $BatchNumber : $($_.Exception.Message)"
            $script:errorCount += $updates.Count
        }
    }
    elseif ($DryRun) {
        Write-Host "DRY RUN: Would update $($updates.Count) items in database" -ForegroundColor Yellow
        $script:successCount += $updates.Count
        
        # Show sample of what would be updated
        $updates | Select-Object -First 3 | ForEach-Object {
            $fieldCount = $_.Keys.Count - 1  # Exclude ItemId
            Write-Host "  Item $($_.ItemId): $fieldCount fields"
        }
    }
}

# Process files in batches
Write-Host "Starting batch processing..." -ForegroundColor Green
$startTime = Get-Date

for ($i = 0; $i -lt $totalFiles; $i += $BatchSize) {
    $batchCount++
    $endIndex = [math]::Min($i + $BatchSize - 1, $totalFiles - 1)
    $batchFiles = $lucyFiles[$i..$endIndex]
    
    Update-Batch -Files $batchFiles -BatchNumber $batchCount
    
    # Show progress
    $percentComplete = [math]::Round((($i + $batchFiles.Count) / $totalFiles) * 100, 2)
    Write-Host "Progress: $percentComplete% complete" -ForegroundColor Cyan
}

# Final results
$endTime = Get-Date
$duration = $endTime - $startTime

Write-Host "`n=== Batch Update Complete ===" -ForegroundColor Green
Write-Host "Total files processed: $processedCount"
Write-Host "Successful updates: $successCount"
Write-Host "Errors: $errorCount"
Write-Host "Skipped: $skippedCount"
Write-Host "Duration: $($duration.TotalMinutes.ToString('F2')) minutes"

# Verify results in database
if (!$DryRun) {
    Write-Host "`nVerifying database updates..." -ForegroundColor Cyan
    
    # Check how many items now have slots data
    $stillMissing = Invoke-SqliteQuery -DataSource $DbPath -Query "
        SELECT COUNT(*) as count 
        FROM raw_item_data 
        WHERE ac > 0 AND (slots IS NULL OR slots = 0)"
    
    Write-Host "Items with AC but still missing slots: $($stillMissing[0].count)"
    
    # Show sample of updated items with slots
    Write-Host "`nSample items with slots now populated:"
    Invoke-SqliteQuery -DataSource $DbPath -Query "
        SELECT id, name, ac, slots, hp, endur 
        FROM raw_item_data 
        WHERE ac > 0 AND slots > 0 
        ORDER BY ac DESC
        LIMIT 10" | Format-Table -AutoSize
}

Write-Host "`nBatch update completed!" -ForegroundColor Green